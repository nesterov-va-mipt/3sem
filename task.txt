subvector

Сегодня на семинаре будет еще одна работа без контеста. Вам нужно написать некоторый объем кода, набор функций, который будет реализовывать расширяемый массив. Назовем его subvector, потому что он очень похож на vector из STL, и основан на той же идее. 

В этом семестре с классами мы еще не работаем, поэтому subvector будет выглядеть как структура и набор функций. Структура представляет собой комплект из указателя на массив в куче, размер памяти, выделенной в этой куче (capacity) и размер той памяти, с которой мы работаем, в которой есть осмысленные данные (top). То есть при работе с такой структурой мы можем выделить себе сколько-то места заранее, а можем расширять место по мере необходимости. Полный список методов, который вам нужно реализовать, в соседней pdf.

Вам нужно реализовать все эти методы (init_from_file необязательно) и вписаться в профайлер - программу, которая проверяет корректность работы вашей программы. Что все методы реализованы, у них правильные интерфейсы (заголовки - тип возвращаемого значения, название, список аргументов), они не теряют данные и память. Проверку на утечки памяти буду проводить при сдаче на сервере, где есть valgrind. Профайлер лежит в соседнем файле с говорящим названием, можете использовать его для отладки. Если у вас линукс или мак, то можете сразу отлаживаться под valgrind, если винда - используйте компы в аудиториях. Ну или можете присылать мне, я буду прогонять на сервере, но у меня большое время отклика))

Для сдачи вам нужно прислать мне код своего subvector'а, я прогоняю его на сервере под valgrind, если все успешно исполняется без утечек памяти, то зачет.

PS. В описании не уточнено, что пустым subvector'ом считается тот, у которого top и capacity по нулям, а mas это NULL.

PPS. У subvector'а два размера. Capacity - это общий объем выделенной памяти, которой можно брать с запасом. Top - размер занятой памяти, осмысленных данных. Size всегда меньше capacity. При удалении элемента уменьшается top, но не capacity. При добавлении элемента top увеличивается, если при этом он становится больше capacity, то перед добавлением элемента нужно вызвать resize.

PPPS. Resize только увеличивает сapacity. Для его уменьшения лучше пользоваться shrink_to_fit и clear, чтобы точно не потерять данные. Если позволить resize уменьшать объем выделенной памяти, то появится вопрос, что делать с элементами, которые остались за бортом. Более рационально повесить этот выбор на пользователя библиотеки (даже если это вы сам, но как бы в роли пользователя). 

PPPPS. По поводу очистки. Destructor - прямо очистить, под ноль, чтобы он был как свежеинициализированный. Clear - только сбросить top, capacity остается прежним.

PPPPPS. Это не контест, поэтому за какой-то дополнительный вывод на экран (например, предупреждение или информация от отладки) штрафов не будет. Только постарайтесь, чтобы его было не очень много, и он не заспамил полезный вывод.


subforwardlist

Думаю, идею вы уже поняли. Нужно вписаться в аналогичный профайлер, только для односвязных списков. Здесь у вас больше шансов запутаться в указателях и потерять куски памяти, поэтому будьте внимательны. Если что-то идет не так или появляется неуверенность в том, сколько звездочек ставить - рисуйте схему. Если и со схемой непонятно - пишите мне, будем думать вместе.

В задании количество звездочек в заголовках функции прикрыто фиговыми листочками - постарайтесь сами понять, где сколько ставить. Можете гадать про профайлеру (смотреть, как эту функцию будут вызывать), но лучше постарайтесь сами догадаться, исходя из того, что функция делает.

Готовый код, аналогично, присылайте мне.

subset

Вам нужно написать аналог std::set. То есть структуру и набор функций, которые обеспечивают работу бинарного дерева поиска. Обязательный набор функций перечислен на третьей странице pdf'ки. Содержимое структуры можете дополнять нужными вам полями, также можете использовать дополнительные структуры данных - например, очередь на двусвязном списке для BFS (обхода в ширину). Или дописывать функции, которые нужны вам для удобства при реализации других функций.

Две функции отмечены красным цветом - их писать непросто и долго, это дополнительный материал. Будет хорошо, если успеете, но лучше потратьте это время на проект. 
Аналогично с балансировкой - это полезно, не очень сложно, но трудозатратно. Оцените свои силы. 

Заметки и комментарии.
0. Пустое дерево - значит, 0 элементов - значит, указатель на NULL.
1. insert не добавляет дубли. Если вы добавляете новый элемент и видите, что он уже есть в дереве - не добавляете ничего.
2. Поиск элемента возвращает указатель на найденный элемент или NULL, если не нашел.
3. DFS и BFS (если что, по этим аббревиатурам можно гуглить) возвращают указатели на массивы, лежащие в куче (очищать их будет вызывающая программа, в нашем случае - профайлер). В этих массивах лежат значения всех ключей дерева в нужном порядке. Если вы хотите пользоваться рекурсией, то советую написать ее отдельно. То есть у вас будет функция-интерфейс, о которой знает вызывающая программа (да, это та самая функция, что написана в pdf'ке) и, отдельно, рекурсивная функция, которая организует сам обход. Тогда функция-интерфейс выделяет память под новый массив, вызывает рекурсивную функцию, выдает ей указатель на дерево и на массив (может, на что-то еще, тут интерфейс не ограничивает вашу фантазию) и возвращает указатель на этот массив в вызывающую функцию.
4. insert возвращает false, если не смог добавить элемент - в том числе, если игнорировал дубль. Аналогично с remove - если элемент не нашелся, то нужно не вылетать с сегфолтом, а спокойно вернуть false.
5. find возвращает указатель на узел, но профайлер с ним ничего делать не будет. В нем указатель используется только для проверки на нашел/не нашел, true/false, практически как булева переменная. Но вам будет удобнее, если функция будет реализована именно в таком виде, с указателем - например, вы сможете использовать ее в insert и remove.
